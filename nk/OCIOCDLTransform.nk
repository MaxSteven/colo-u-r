# Source code: https://github.com/imageworks/OpenColorIO/blob/master/share/nuke/ocionuke/cdl.py
# Source code: nuke, the foundry
set cut_paste_input [stack 0]
version 10.0 v4
push $cut_paste_input
OCIOCDLTransform {
 slope {1 1 1}
 offset {0 0 0}
 power {1 1 1}
 working_space AlexaV3LogC
 name OCIOCDLTransform
 label "\[value direction]"
 selected true
 xpos 1046
 ypos 190
 addUserKnob {20 User l Tools}
 addUserKnob {22 importcdlfrommetadata l "import cdl from metadata" T "n=nuke.thisNode()\nn\['read_from_file'].setValue(False)\nn\['slope'].setValue(\[n.metadata()\['exr/RSlope'],n.metadata()\['exr/GSlope'],n.metadata()\['exr/BSlope']])\nn\['offset'].setValue(\[n.metadata()\['exr/ROffset'],n.metadata()\['exr/GOffset'],n.metadata()\['exr/BOffset']])\nn\['power'].setValue(\[n.metadata()\['exr/RPower'],n.metadata()\['exr/GPower'],n.metadata()\['exr/BPower']])\nn\['saturation'].setValue(n.metadata()\['exr/Saturation'])\nn\['label'].setValue(n.metadata()\['exr/Cut_Clip_Name'] +  '\\n\[value direction]')" +STARTLINE}
 addUserKnob {22 pyMod l INVISIBLE -STARTLINE +INVISIBLE T "\"\"\"Various utilities relating to the OCIOCDLTransform node\n\"\"\"\n\nimport nuke\nimport PyOpenColorIO as OCIO\nimport xml.etree.ElementTree as ET\n\n\ndef _node_to_cdltransform(node):\n    \"\"\"From an OCIOCDLTransform node, returns a PyOpenColorIO\n    CDLTransform object, which could be used to write XML\n    \"\"\"\n\n    # Color_Knob.value returns single float if control is not\n    # expanded, so use value(index=...) to always get three values\n    slope = \[node\['slope'].value(x) for x in range(3)]\n    offset = \[node\['offset'].value(x) for x in range(3)]\n    power = \[node\['power'].value(x) for x in range(3)]\n    sat = node\['saturation'].value()\n    cccid = node\['cccid'].value()\n\n    cdl = OCIO.CDLTransform()\n    cdl.setSlope(slope)\n    cdl.setOffset(offset)\n    cdl.setPower(power)\n    cdl.setSat(sat)\n    cdl.setID(cccid)\n\n    return cdl\n\n\ndef _cdltransform_to_node(cdl, node):\n    \"\"\"From an XML string, populates the parameters on an\n    OCIOCDLTransform node\n    \"\"\"\n\n    # Treat \"node\" as a dictionary of knobs, as the \"node\" argument could be\n    # a the return value of PythonPanel.knob(), as in SelectCCCIDPanel\n\n    node\['slope'].setValue(cdl.getSlope())\n    node\['offset'].setValue(cdl.getOffset())\n    node\['power'].setValue(cdl.getPower())\n    node\['saturation'].setValue(cdl.getSat())\n    node\['cccid'].setValue(cdl.getID())\n\n\ndef _xml_colorcorrection_to_cdltransform(xml, cccposition):\n    \"\"\"From an XML string, return a CDLTransform object, if the cccid\n    is absent from the XML the given cccposition will be used instead \n    \"\"\"\n    ccxml = ET.tostring(xml)\n    cdl = OCIO.CDLTransform()\n    cdl.setXML(ccxml)\n    if \"cccid\" not in xml.getchildren():\n     cdl.setID(str(cccposition))\n\n    return cdl\n\ndef _xml_to_cdltransforms(xml):\n    \"\"\"Given some XML as a string, returns a list of CDLTransform\n    objects for each ColorCorrection (returns a one-item list for a\n    .cc file)\n    \"\"\"\n\n    tree = ET.fromstring(xml)\n\n    # Strip away xmlns\n    for elem in tree.getiterator():\n        if elem.tag.startswith(\"\{\"):\n            elem.tag = elem.tag.partition(\"\}\")\[2]\n\n    filetype = tree.tag\n\n    cccposition = 0\n    if filetype == \"ColorCorrection\":\n        return \[_xml_colorcorrection_to_cdltransform(tree, cccposition)]\n\n    elif filetype in \[\"ColorCorrectionCollection\", \"ColorDecisionList\"]:\n        allcdl = \[]\n        for cc in tree.getchildren():\n            if cc.tag == \"ColorDecision\":\n                cc = cc.getchildren()\[0] # TODO: something better here\n            if cc.tag != \"ColorCorrection\": continue\n            allcdl.append(_xml_colorcorrection_to_cdltransform(cc, cccposition))\n            cccposition += 1\n        return allcdl\n\n    else:\n        raise RuntimeError(\n            \"The supplied file did not have the correct root element, expected\"\n            \" 'ColorCorrection' or 'ColorCorrectionCollection' or 'ColorDecisionList', got %r\" % (filetype))\n\n\ndef _cdltransforms_to_xml(allcc):\n    \"\"\"Given a list of CDLTransform objects, returns an XML string\n    \"\"\"\n\n    root = ET.Element(\"ColorCorrectionCollection\")\n    root.attrib\['xmlns'] = 'urn:ASC:CDL:v1.2'\n\n    for cc in allcc:\n        cur = ET.fromstring(cc.getXML())\n\n        # Strip away xmlns\n        for elem in cur.getiterator():\n            if elem.tag.startswith(\"\{\"):\n                elem.tag = elem.tag.partition(\"\}\")\[2]\n        root.append(cur)\n\n    return ET.tostring(root)\n\n\ndef SelectCCCIDPanel(*args, **kwargs):\n    # Wrap class definition in a function, so nukescripts.PythonPanel\n    # is only accessed when ``SelectCCCIDPanel()`` is called,\n    # https://github.com/imageworks/OpenColorIO/issues/277\n\n    import nukescripts\n\n    class _SelectCCCIDPanel(nukescripts.PythonPanel):\n        \"\"\"Allows the user to select from a list of CDLTransform\n        objects\n        \"\"\"\n\n        def __init__(self, allcdl):\n            super(_SelectCCCIDPanel, self).__init__()\n            self.available = \{\}\n            for cur in allcdl:\n                self.available\[cur.getID()] = cur\n\n            self.addKnob(nuke.Enumeration_Knob(\"cccid\", \"cccid\", self.available.keys()))\n            self.addKnob(nuke.Text_Knob(\"divider\"))\n            self.addKnob(nuke.Color_Knob(\"slope\"))\n            self.addKnob(nuke.Color_Knob(\"offset\"))\n            self.addKnob(nuke.Color_Knob(\"power\"))\n            self.addKnob(nuke.Double_Knob(\"saturation\"))\n\n        def selected(self):\n            return self.available\[self.knobs()\['cccid'].value()]\n\n        def knobChanged(self, knob):\n            \"\"\"When the user selects a cccid, a grade-preview knobs are set.\n\n            This method is triggered when any knob is changed, which has the\n            useful side-effect of preventing changing the preview values, while\n            keeping them selectable for copy-and-paste.\n            \"\"\"\n            _cdltransform_to_node(self.selected(), self.knobs())\n\n    return _SelectCCCIDPanel(*args, **kwargs)\n\n\ndef export_as_cc(node = None, filename = None):\n    \"\"\"Export a OCIOCDLTransform node as a ColorCorrection XML file\n    (.cc)\n\n    If node is None, \"nuke.thisNode()\" will be used. If filename is\n    not specified, the user will be prompted.\n    \"\"\"\n\n    if node is None:\n        node = nuke.thisNode()\n\n    cdl = _node_to_cdltransform(node)\n\n    if filename is None:\n        ccfilename = nuke.getFilename(\"Color Correction filename\", pattern = \"*.cc\")\n        if ccfilename is None:\n            # User clicked cancel\n            return\n\n    xml = cdl.getXML()\n    print \"Writing to %s - contents:\\n%s\" % (ccfilename, xml)\n    open(ccfilename, \"w\").write(xml)\n\n\ndef import_cc_from_xml(node = None, filename = None):\n    \"\"\"Import a ColorCorrection XML (.cc) into a OCIOCDLTransform node.\n\n    If node is None, \"nuke.thisNode()\" will be used. If filename is\n    not specified, the user will be prompted.\n    \"\"\"\n\n    if node is None:\n        node = nuke.thisNode()\n\n    if filename is None:\n        ccfilename = nuke.getFilename(\"Color Correction filename\", pattern = \"*.cc *.ccc *.cdl\")\n        if ccfilename is None:\n            # User clicked cancel\n            return\n\n    xml = open(ccfilename).read()\n\n    allcc = _xml_to_cdltransforms(xml)\n\n    if len(allcc) == 1:\n        _cdltransform_to_node(allcc\[0], node)\n    elif len(allcc) > 1:\n        do_selectcccid = nuke.ask(\n            \"Selected a ColorCorrectionCollection, do you wish to select a ColorCorrection from this file?\")\n        if do_selectcccid:\n            sel = SelectCCCIDPanel(allcc)\n            okayed = sel.showModalDialog()\n            if okayed:\n                cc = sel.selected()\n                _cdltransform_to_node(cc, node)\n        else:\n            return ccfilename #rmk hack\n    else:\n        nuke.message(\"The supplied file (%r) contained no ColorCorrection's\" % ccfilename)\n        return\n    return ccfilename #rmk hack\n\n\ndef export_multiple_to_ccc(filename = None):\n    \"\"\"Exported all selected OCIOCDLTransform nodes to a\n    ColorCorrectionCollection XML file (.ccc)\n    \"\"\"\n\n    if filename is None:\n        filename = nuke.getFilename(\"Color Correction XML file\", pattern = \"*.cc *.ccc\")\n        if filename is None:\n            # User clicked cancel\n            return\n\n    allcc = \[]\n    for node in nuke.selectedNodes(\"OCIOCDLTransform\"):\n        allcc.append(_node_to_cdltransform(node))\n\n    xml = _cdltransforms_to_xml(allcc)\n    print \"Writing %r, contents:\\n%s\" % (filename, xml)\n    open(filename, \"w\").write(xml)\n\n\ndef import_multiple_from_ccc(filename = None):\n    \"\"\"Import a ColorCorrectionCollection file (.ccc) into multiple\n    OCIOCDLTransform nodes. Also creates a single node for a .cc file\n    \"\"\"\n\n    if filename is None:\n        filename = nuke.getFilename(\"Color Correction XML file\", pattern = \"*.cc *.ccc *.cdl\")\n        if filename is None:\n            # User clicked cancel\n            return\n\n    xml = open(filename).read()\n    allcc = _xml_to_cdltransforms(xml)\n\n    def _make_node(cdl):\n        newnode = nuke.nodes.OCIOCDLTransform(inputs = nuke.selectedNodes()\[:1])\n        _cdltransform_to_node(cdl, newnode)\n        newnode\['label'].setValue(\"id: \[value cccid]\")\n\n    if len(allcc) > 0:\n        for cc in allcc:\n            _make_node(cc)\n    else:\n        nuke.message(\"The supplied file (%r) contained no ColorCorrection's\" % filename)\n\n\ndef select_cccid_for_filetransform(node = None, fileknob = 'file', cccidknob = 'cccid'):\n    \"\"\"Select cccid button for the OCIOFileTransform node, also used\n    in OCIOCDLTransform. Presents user with list of cccid's within the\n    specified .ccc file, and sets the cccid knob to the selected ID.\n    \"\"\"\n\n    if node is None:\n        node = nuke.thisNode()\n\n    filename = node\[fileknob].value()\n\n    try:\n        xml = open(filename).read()\n    except IOError, e:\n        nuke.message(\"Error opening src file: %s\" % e)\n        raise\n\n    allcc = _xml_to_cdltransforms(xml)\n\n    if len(allcc) == 0:\n        nuke.message(\"The file (%r) contains no ColorCorrection's\")\n        return\n\n    sel = SelectCCCIDPanel(allcc)\n    okayed = sel.showModalDialog()\n    if okayed:\n        node\[cccidknob].setValue(sel.selected().getID())"}
 addUserKnob {22 importxmlcdl l "Import XML CDL file" T "import sys\nfrom os.path import basename\n\ntry:\n    n=nuke.thisNode()\n    n\['pyMod'].execute()\n    if n.Class() == 'OCIOCDLTransform':\n        n\['read_from_file'].setValue(True)\n        #n\['file'].setValue(filepath)\n        filepath =import_cc_from_xml()\n        n\['label'].setValue(os.path.basename(filepath)+  '\\n\[value direction]')\n    else:\n        nuke.message('err.. pls select a OCIO CDL TRANSFORM node')\nexcept:\n    print(\"Unexpected error:\", sys.exc_info()\[0])\n    raise" +STARTLINE}
 addUserKnob {20 info}
 addUserKnob {26 version_1 l version: T 01}
 addUserKnob {26 source l source: T " (v01) https://github.com/openNuke/colo-u-r "}
 addUserKnob {26 txt1 l created: T "01/01/2017 r.kaniewski "}
 addUserKnob {26 fork l fork: T " "}
 addUserKnob {26 modified l modified: T " "}
 addUserKnob {26 note l note: T "set colourspace to gamut that the cdl was generated in."}
}

